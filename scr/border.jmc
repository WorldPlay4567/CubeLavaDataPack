Scoreboard.add(pos_x,dummy);
Scoreboard.add(pos_y,dummy);
Scoreboard.add(pos_z,dummy);

Scoreboard.add(id,dummy);

Scoreboard.add(border,dummy);
Scoreboard.add(math,dummy);
border::size;

class border {



    function summon() {
        id:id ++;
        id:@s = id:id;

        execute summon item_display run {
            data merge entity @s {Tags:["border"],item:{count:1,id:"minecraft:paper"}};
            data merge entity @s {view_range:2.0f,start_interpolation:-1,transformation:{left_rotation:[0.0f,0.0f,0.0f,1.0f],right_rotation:[0.0f,0.0f,0.0f,1.0f],scale:[100.0f,700.0f,100.0f]}};
            id:@s = id:id;
        }

    }

    function math() {



        this.main();
    }

    
    function main() {
            execute as @s at @s run {
                tag @s add leader;
                execute as @e[tag=border] if score @s id = @a[tag=leader,limit=1] id run { 

                tp @s ~ ~ ~ 90 0;

                pos_x:@a[tag=leader,limit=1] = data get entity @a[tag=leader,limit=1] Pos[0] 100;
                pos_y:@a[tag=leader,limit=1] = data get entity @a[tag=leader,limit=1] Pos[1] 100;
                pos_z:@a[tag=leader,limit=1] = data get entity @a[tag=leader,limit=1] Pos[2] 100;

                execute store result entity @s transformation.translation[2] float 0.01 run pos_x:@a[tag=leader,limit=1] *= 1;

                pos_y:@a[tag=leader,limit=1] *= -1;
                execute store result entity @s transformation.translation[1] float 0.01 run pos_y:@a[tag=leader,limit=1] += 15000 ;


                execute store result entity @s transformation.translation[0] float 0.01 run pos_z:@a[tag=leader,limit=1] *= -1;

                }
                tag @s remove leader;
        } 

        this.sizeBorder();
        this.damageZone();
    }

    function damageZone() {

        execute store result storage lava_rising:border size int 0.01 run $size.get();

        $size_temp = $size;
        $size_two  = $size_temp /= 2;
         execute store result storage lava_rising:border size_two int 0.01 run $size_two.get();

        this.damageZoneMacros() with storage lava_rising:border;
        function damageZoneMacros() {
            $execute positioned 0 100 0 positioned ~-$(size_two) -64 ~-$(size_two) as @a run{
                if (!entity @s[dx=$(size),dy=250,dz=$(size)]) {
                    effect give @s minecraft:darkness 2 255 true;
                    tag @s add in_zone;
                }
            };

            $execute positioned 0 100 0 positioned ~-$(size_two) -64 ~-$(size_two) as @a run{
                if (entity @s[dx=$(size),dy=250,dz=$(size)]) {
                    tag @s remove in_zone;
                }
            };
            
        }


    }
    
    function sizeBorder() {
            execute as @e[tag=border] store result entity @s transformation.scale[0] float 0.01 run $size.get(); 
            execute as @e[tag=border] store result entity @s transformation.scale[2] float 0.01 run $size.get(); 

    }

    function setSize() {

        $execute run scoreboard players set $size_time border $(size);
        $execute run scoreboard players set $time_time border $(time);

        //Получить разницу между барьером
        math:size = border:$size_time;
        math:size_now = __variable__:$size;
        math:size = math:size_now -= math:size;

        //Перевести в тики
        math:time = border:$time_time;
        math:time *= 20;

        //Выход сколько за тик надо отнять и сколько раз повторить
        border:size_remove = math:size /= math:time;
        border:time = math:time;     

        this.editSize();
    }

    function editSize() {
        schedule 1t replace {
            if(border:time matches 0..240000 ) {
                border:time -= 1;
                this.editSize();
            }

        }

        __variable__:$size -= border:size_remove;
    }

    function test() {
       execute run function lava_rising:border/setsize {"size":"1000","time":"20"};
    }
}